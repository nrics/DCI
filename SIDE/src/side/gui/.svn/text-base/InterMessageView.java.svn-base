package side.gui;

import java.beans.EventHandler;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.jface.resource.JFaceResources;
import org.eclipse.jface.viewers.ArrayContentProvider;
import org.eclipse.jface.viewers.ColumnLabelProvider;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.jface.viewers.TableViewer;
import org.eclipse.jface.viewers.TableViewerColumn;
import org.eclipse.swt.SWT;
import org.eclipse.swt.custom.CTabFolder;
import org.eclipse.swt.custom.CTabItem;
import org.eclipse.swt.custom.ScrolledComposite;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.graphics.Font;
import org.eclipse.swt.graphics.Point;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.layout.RowData;
import org.eclipse.swt.layout.RowLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Event;
import org.eclipse.swt.widgets.Group;
import org.eclipse.swt.widgets.Label;
import org.eclipse.swt.widgets.Listener;
import org.eclipse.swt.widgets.TabFolder;
import org.eclipse.swt.widgets.TabItem;
import org.eclipse.swt.widgets.Table;
import org.eclipse.swt.widgets.TableColumn;
import org.eclipse.swt.widgets.Text;
import org.eclipse.ui.IPartListener2;
import org.eclipse.ui.ISelectionListener;
import org.eclipse.ui.ISizeProvider;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.IWorkbenchPartReference;
import org.eclipse.ui.part.ViewPart;
import org.eclipse.xsd.XSDComplexTypeDefinition;
import org.eclipse.xsd.XSDConcreteComponent;
import org.eclipse.xsd.XSDElementDeclaration;
import org.eclipse.xsd.XSDParticle;
import org.eclipse.xsd.XSDTypeDefinition;
import org.eclipse.xsd.util.XSDResourceFactoryImpl;
import org.eclipse.xsd.util.XSDResourceImpl;
import org.osgi.framework.BundleContext;
import org.osgi.framework.FrameworkUtil;
import org.w3c.dom.Element;


import side.model.ComplexElement;
import side.model.ComplexElementType;
import side.model.Dependency;
import side.service.impl.FileManager;

public class InterMessageView extends ViewPart {
	
	public static final String ID = "side.gui.InterMessageView";
	
	private Composite top;
	private ScrolledComposite scrollComposite;
	private Composite scrollCompositeChild;
	private ScrolledComposite scrollComposite2;
	private Composite scrollCompositeChild2;
	private TableViewer tableViewer;
	private TableViewer tableViewer2;
	private Font boldFont = JFaceResources.getFontRegistry().getBold(JFaceResources.DEFAULT_FONT);    
	private Label vsLabel;
	private Text dciScore;
	private Text dci2Score;

	@Override
	public void createPartControl(Composite parent) {
		// TODO Auto-generated method stub

		CTabFolder  folder = new CTabFolder(parent, SWT.NONE);
		folder.setBorderVisible(true);
//		folder.setTabHeight(25);
		folder.setSelectionBackground(new Color[] {
		        parent.getDisplay().getSystemColor(SWT.COLOR_TITLE_BACKGROUND),
		        parent.getDisplay().getSystemColor(SWT.COLOR_TITLE_BACKGROUND_GRADIENT),
		        parent.getDisplay().getSystemColor(SWT.COLOR_TITLE_BACKGROUND) }, new int[] { 4, 60 });
		folder.setSelectionForeground(parent.getDisplay().getSystemColor(SWT.COLOR_TITLE_FOREGROUND)); 

		GridLayout gridTop = new GridLayout();
		gridTop.marginHeight = 0;
		gridTop.marginWidth = 0;
		gridTop.horizontalSpacing = 10;
		gridTop.numColumns = 2;
		
	    //Tab 1
	    CTabItem tab1 = new CTabItem(folder, SWT.NONE);
	    tab1.setText(" Metrics ");
	    
		top = new Composite(folder, SWT.NONE);
		top.setLayout(gridTop);
		
		GridData gridDciScore = new GridData();
		gridDciScore.widthHint = 130;
		gridDciScore.horizontalSpan = 2;
	    
	    dciScore = new Text (top, SWT.NONE);
	    dciScore.setLayoutData(gridDciScore);
	    
	    dci2Score = new Text (top, SWT.NONE);
	    dci2Score.setLayoutData(gridDciScore);
//	    dciScore.setText("DCI Metric : "+df.format(metricResult));
	    
		tab1.setControl(top);
		 
	    //Tab 2
		CTabItem tab2 = new CTabItem(folder, SWT.NONE);
	    tab2.setText(" Message Combination ");
	    
	    gridTop = new GridLayout();
	    gridTop.marginHeight = 0;
	    gridTop.marginWidth = 0;
	    
		top = new Composite(folder, SWT.NONE);
		top.setLayout(gridTop);
		
    	scrollComposite = new ScrolledComposite(top, SWT.V_SCROLL | SWT.BORDER);
 		scrollComposite.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true, 1, 1));

 		scrollCompositeChild = new Composite(scrollComposite, SWT.NONE);
		scrollCompositeChild.setLayout(new GridLayout(1, true));

		scrollComposite.setExpandHorizontal(true);
		scrollComposite.setExpandVertical(true);
		scrollComposite.setContent(scrollCompositeChild);
		
		tab2.setControl(top);
		
	    //Tab 3
		CTabItem tab3 = new CTabItem(folder, SWT.NONE);
	    tab3.setText(" DCI 2's Message Combination ");
	    
	    gridTop = new GridLayout();
	    gridTop.marginHeight = 0;
	    gridTop.marginWidth = 0;
	    
		top = new Composite(folder, SWT.NONE);
		top.setLayout(gridTop);
		
    	scrollComposite2 = new ScrolledComposite(top, SWT.V_SCROLL | SWT.BORDER);
 		scrollComposite2.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true, 1, 1));

 		scrollCompositeChild2 = new Composite(scrollComposite2, SWT.NONE);
		scrollCompositeChild2.setLayout(new GridLayout(1, true));

		scrollComposite2.setExpandHorizontal(true);
		scrollComposite2.setExpandVertical(true);
		scrollComposite2.setContent(scrollCompositeChild2);
		
		tab3.setControl(top);
		
		folder.setSelection(tab1);
//		// add this view as a selection listener to the workbench page
//		getSite().getPage().addSelectionListener(FileUploadView.ID,(ISelectionListener) this);
	}
	
	private void createViewer() {
		tableViewer = new TableViewer(scrollCompositeChild, SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL | SWT.FULL_SELECTION | SWT.BORDER);
		createColumns(scrollCompositeChild);
		final Table table = tableViewer.getTable();
		table.setHeaderVisible(true);
		table.setLinesVisible(true);

		tableViewer.setContentProvider(new ArrayContentProvider());

//		 Make the selection available to other views
//		getSite().setSelectionProvider(tableViewer);
		// Set the sorter for the table

		// Layout the viewer
		GridData gridData = new GridData();
		gridData.verticalAlignment = GridData.BEGINNING;
//		gridData.horizontalSpan = 2;
//		gridData.grabExcessHorizontalSpace = true;
//		gridData.grabExcessVerticalSpace = true;
		gridData.horizontalAlignment = GridData.FILL;
		tableViewer.getControl().setLayoutData(gridData);
	}
	
	private void createViewer2() {
		tableViewer2 = new TableViewer(scrollCompositeChild2, SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL | SWT.FULL_SELECTION | SWT.BORDER);
		createColumns2(scrollCompositeChild2);
		final Table table2 = tableViewer2.getTable();
		table2.setHeaderVisible(true);
		table2.setLinesVisible(true);

		tableViewer2.setContentProvider(new ArrayContentProvider());

//		 Make the selection available to other views
//		getSite().setSelectionProvider(tableViewer);
		// Set the sorter for the table

		// Layout the viewer
		GridData gridData2 = new GridData();
		gridData2.verticalAlignment = GridData.BEGINNING;
//		gridData.horizontalSpan = 2;
//		gridData.grabExcessHorizontalSpace = true;
//		gridData.grabExcessVerticalSpace = true;
		gridData2.horizontalAlignment = GridData.FILL;
		tableViewer2.getControl().setLayoutData(gridData2);
	}

	public TableViewer getTableViewer() {
		return tableViewer;
	}
	
	// This will create the columns for the table
		private void createColumns(final Composite parent) {
			String[] titles = { "Type", "Quantity" };
			int[] bounds = { 600, 100 };

			// First column is for the first name
			TableViewerColumn col = createTableViewerColumn(titles[0], bounds[0], 0);
			col.setLabelProvider(new ColumnLabelProvider() {
				@Override
				public String getText(Object element) {
					Dependency p = (Dependency) element;
					return p.getType();
				}
			});

			// Second column is for the last name
			col = createTableViewerColumn(titles[1], bounds[1], 1);
			col.setLabelProvider(new ColumnLabelProvider() {
				@Override
				public String getText(Object element) {
					Dependency p = (Dependency) element;
					return p.getQuantity();
				}
			});

		}
		
		private void createColumns2(final Composite parent) {
			String[] titles = { "Type", "Quantity" };
			int[] bounds = { 600, 100 };
			
			// First column is for the first name
			TableViewerColumn col2 = createTableViewerColumn2(titles[0], bounds[0], 0);
			col2.setLabelProvider(new ColumnLabelProvider() {
				@Override
				public String getText(Object element) {
					Dependency p = (Dependency) element;
					return p.getType();
				}
			});

			// Second column is for the last name
			col2 = createTableViewerColumn2(titles[1], bounds[1], 1);
			col2.setLabelProvider(new ColumnLabelProvider() {
				@Override
				public String getText(Object element) {
					Dependency p = (Dependency) element;
					return p.getQuantity();
				}
			});
		}
		
	private TableViewerColumn createTableViewerColumn(String title, int bound, final int colNumber) {
		final TableViewerColumn viewerColumn = new TableViewerColumn(tableViewer, SWT.NONE);
		final TableColumn column = viewerColumn.getColumn();
		column.setText(title);
		column.setWidth(bound);
		column.setMoveable(false);
		column.setResizable(false);
		return viewerColumn;
	}
	
	private TableViewerColumn createTableViewerColumn2(String title, int bound, final int colNumber) {
		final TableViewerColumn viewerColumn = new TableViewerColumn(tableViewer2, SWT.NONE);
		final TableColumn column = viewerColumn.getColumn();
		column.setText(title);
		column.setWidth(bound);
		column.setMoveable(false);
		column.setResizable(false);
		return viewerColumn;
	}
	
	@Override
	public void setFocus() {
		// TODO Auto-generated method stub

	}
	
	public Object getAdapter(Class adapter) {
	    if (ISizeProvider.class == adapter) {
	        return new ISizeProvider() {
	            public int getSizeFlags(boolean width) {
	                return SWT.MIN | SWT.MAX | SWT.FILL;
	            }

	            public int computePreferredSize(boolean width, int availableParallel, int availablePerpendicular, int preferredResult) {
	            	return width ? 1300 : preferredResult;
	            }
	        };
	    }
	    return super.getAdapter(adapter);
	}

//	@Override
//	public void selectionChanged(IWorkbenchPart part, ISelection selection) {
//		// TODO Auto-generated method stub
//		
//		if (part instanceof FileUploadView) {  
//			
////			   side.model.File uploadedFile = (side.model.File) ((StructuredSelection) selection).getFirstElement(); 
//
////			   if (uploadedFile != null) {
//
////			   }
//		}  	
//	}
	
	private void rearrangeInterface() {
		   scrollComposite.setMinSize(scrollCompositeChild.computeSize(SWT.DEFAULT, SWT.DEFAULT));
		   scrollCompositeChild.layout();
		   
		   scrollComposite2.setMinSize(scrollCompositeChild2.computeSize(SWT.DEFAULT, SWT.DEFAULT));
		   scrollCompositeChild2.layout();
	}
	
	private void disposeOldWidgets() {

		 for (int i=scrollCompositeChild.getChildren().length-1; i >= 0; i--) {
			 if ((scrollCompositeChild.getChildren()[i] != null) && (!scrollCompositeChild.getChildren()[i].isDisposed())) {
				 scrollCompositeChild.getChildren()[i].dispose();
			 }
		 }
		 for (int i=scrollCompositeChild2.getChildren().length-1; i >= 0; i--) {
			 if ((scrollCompositeChild2.getChildren()[i] != null) && (!scrollCompositeChild2.getChildren()[i].isDisposed())) {
				 scrollCompositeChild2.getChildren()[i].dispose();
			 }
		 }
	}

	public void updateView(TreeMap<String, List<ComplexElementType>> complexElListMap) {		
	    disposeOldWidgets();
	    compareFiles(complexElListMap);
	    rearrangeInterface();
	}
	
	public void setCombinationResults(Entry<String, List<ComplexElementType>> firstFile, Entry<String, List<ComplexElementType>> secondFile, List<Dependency> dependencies) {
   		vsLabel = new Label(scrollCompositeChild, SWT.NONE);
   		vsLabel.setText("====="+firstFile.getKey()+" vs "+secondFile.getKey()+"=====\n");
   		vsLabel.setFont(boldFont);
   		
		if (dependencies.size() != 0) {
    		createViewer();
    		tableViewer.setInput(dependencies);
		}
	}
	
	public void setCombination2Results(Entry<String, List<ComplexElementType>> firstFile, Entry<String, List<ComplexElementType>> secondFile, List<Dependency> dependencies) {
   		vsLabel = new Label(scrollCompositeChild2, SWT.NONE);
   		vsLabel.setText("====="+firstFile.getKey()+" vs "+secondFile.getKey()+"=====\n");
   		vsLabel.setFont(boldFont);
   		
		if (dependencies.size() != 0) {
    		createViewer2();
    		tableViewer2.setInput(dependencies);
		}
	}
	
	private double linkAndComputeComplexElements(Object file1, Object file2) {
		
		TreeMap<String, Integer> elementTypeMap = new TreeMap<String, Integer>();
		List<Dependency> dependencies = new ArrayList<Dependency>();

		double totalSharedCElements = 0.00;
		
		Entry<String, List<ComplexElementType>> firstFile = (Entry<String, List<ComplexElementType>>) file1;
		Entry<String, List<ComplexElementType>> secondFile = (Entry<String, List<ComplexElementType>>) file2;

		for (int l=0; l < firstFile.getValue().size(); l++) {
			int quantity = 0;
			ComplexElementType file1CElementType = firstFile.getValue().get(l);
			
			for (int k=0; k < secondFile.getValue().size(); k++) {
				ComplexElementType file2CElementType = secondFile.getValue().get(k);
				
				if (file1CElementType.getName().equals(file2CElementType.getName())) {
					quantity = file1CElementType.getQuantity()*file2CElementType.getQuantity();
					Dependency dependency = new Dependency();
					dependency.setType(file2CElementType.getName());
					dependency.setQuantity(Integer.toString(quantity));	
					
					dependencies.add(dependency);
					
					totalSharedCElements = quantity+totalSharedCElements;
				}
			} 
			elementTypeMap.put(file1CElementType.getName(), quantity);
		}
		setCombinationResults(firstFile, secondFile, dependencies);
		return totalSharedCElements;
	}
	
	private double linkAndComputeComplexElements2(Object file1, Object file2) {
		
		List<Dependency> dependencies2 = new ArrayList<Dependency>();

		double totalSharedCElements = 0.00;
		
		Entry<String, List<ComplexElementType>> firstFile = (Entry<String, List<ComplexElementType>>) file1;
		Entry<String, List<ComplexElementType>> secondFile = (Entry<String, List<ComplexElementType>>) file2;

		for (int l=0; l < firstFile.getValue().size(); l++) {
			int quantity = 0;
			ComplexElementType file1CElementType = firstFile.getValue().get(l);
			
			for (int k=0; k < secondFile.getValue().size(); k++) {
				ComplexElementType file2CElementType = secondFile.getValue().get(k);
				
				if (file1CElementType.getName().equals(file2CElementType.getName())) {
//					quantity = file1CElementType.getQuantity()*file2CElementType.getQuantity();
					
					Dependency dependency = new Dependency();
					dependency.setType(file2CElementType.getName());
					dependency.setQuantity(Integer.toString(1));	
					
					dependencies2.add(dependency);
					
					totalSharedCElements = 1+totalSharedCElements;
				}
			} 
		}
		setCombination2Results(firstFile, secondFile, dependencies2);
		return totalSharedCElements;
	}
	
	public void compareFiles(TreeMap<String, List<ComplexElementType>> complexElListMap) {
		
		Object[] complexElList = complexElListMap.entrySet().toArray();
		double totalMessageCombinations = 0;
		double totalSharedCElements = 0;
		double totalSharedCElements2 = 0;


		for (int i=0; i < complexElList.length; i++) {
//        	System.out.println("Key 1 : " + complexElList[i]+"=============\n");
    		for (int k=i+1; k < complexElList.length; k++) {
//            	System.out.println("Key 2 : " + complexElList[k]+"=============\n");
    			totalSharedCElements = totalSharedCElements+linkAndComputeComplexElements(complexElList[i], complexElList[k]);
    			totalSharedCElements2 = totalSharedCElements2+linkAndComputeComplexElements2(complexElList[i], complexElList[k]);
        		totalMessageCombinations++;
    		}
		}
		DecimalFormat df = new DecimalFormat("#.##");
		double dciResult = totalSharedCElements/totalMessageCombinations;
		double dciResult2 = totalSharedCElements2/totalMessageCombinations;

		dciScore.setText("DCI Score : "+df.format(dciResult));
		dci2Score.setText("DCI2 Score : "+df.format(dciResult2));

	}
	
//	public void setDCIScore(File uploadedFile, int totalSharedCElements, int totalMessageCombinations) {
//		FileManager fileMgr = new FileManager();
//		DecimalFormat df = new DecimalFormat("#.##");
////		System.out.print(totalSharedCElements+" totalSharedCElements\n");
////		System.out.print(totalMessageCombinations+" totalMessageCombinations\n");
//
//		double metricResult = (double)totalSharedCElements/totalMessageCombinations;
//		
//		dciScore.setText("DCI Score : "+df.format(metricResult));
//	    fileMgr.deleteFile(uploadedFile);
//	}

}
